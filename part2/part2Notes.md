### `Part 2: (a)` - Rendering a collection, modules
* What's the difference between an experienced JavaScript programmer and a rookie? The experienced one uses console.log 10-100 times more.
* When something does not work, don't just guess what's wrong. Instead, log or use some other way of debugging.
* the list items, i.e. the elements generated by the `map()` method, must each have a unique key value: an attribute called key.
* Notice the use of `map()`. `map()` always creates a new array.
* Anti-pattern: Array Indexes as Keys _(see readings)_.
* Common practice is to declare each component in their own file as an ES6-module, in their folder `components`.
* To import components according to ^ => `'./components/Note'`
---
---
### `Part 2: (b)` - Forms
* How do we access the data contained in the form's input element?
  * There are many ways to accomplish this; the first method we will take a look at is through the use of so-called controlled components.
* Since we assigned a piece of the App component's state as the value attribute of the input element, the App component now controls the behavior of the input element.
* My head suddenly can't wrap around the fact of using `useState()`
---
---
### `Part 2: (c)` - Getting data from server0
* This [json-server](https://github.com/typicode/json-server) looks helpful.
* json-server mimicks the work of a backend, the file `db.json` is now on a localhost, of which you can request to CRUD.
* `XMLHttpRequest,` otherwise known as an HTTP request made using an XHR object. This is a technique introduced in 1999, which every browser has supported for a good while now.
* The use of XHR is no longer recommended, and browsers already widely support the fetch method, which is based on so-called promises, instead of the event-driven model used by XHR.
* JavaScript engines, or runtime environments, follow the asynchronous model. In principle, this requires all IO-operations (with some exceptions) to be executed as non-blocking. This means that code execution continues immediately after calling an IO function, without waiting for it to return.
  * When an asynchronous operation is completed, or, more specifically, at some point after its completion, the JavaScript engine calls the event handlers registered to the operation.
* Synchronous Code
  * Code execution from top to bottom.
  * ?Wait for reply, in terms of code.?
* Asynchronous
  * Code execution isn't exactly from top to bottom, runtime envinronemnt calls some part of code at a later time.
  * ?No wait for reply, im terms of code.?
  * Event-driven (e.g. Event handler)
  * Who ?watches? and ?deals? with requests & fires the event-handlers?
* For the browser to remain responsive, i.e., to be able to continuously react to user operations with sufficient speed, the code logic needs to be such that no single computation can take too long.
  * JS is single-threaded.
* `fetch()` is a great tool. It is standardized and supported by all modern browsers.
  * we will be using the axios library instead.
* practically all JavaScript projects are defined using the node package manager, aka npm.
* There is a fine difference in the parameters. axios is installed as a runtime dependency of the application, because the execution of the program requires the existence of the library. On the other hand, json-server was installed as a development dependency (--save-dev), since the program itself doesn't require it. 
* A Promise is an object representing the eventual completion or failure of an **asynchronous operation**.
* If, and when, we want to access the result of the operation represented by the promise, we must register an event handler to the promise. This is achieved using the method `then()`.
* Storing the promise object in a variable is generally unnecessary, and it's instead common to chain the then method call to the axios method call, so that it follows it directly.
* A more readable way to format chained method calls is to place each call on its own line.
```JS
axios
  .get('http://localhost:3001/notes')
  .then(response => {
    const notes = response.data
    console.log(notes)
  })
```
* The data returned by the server (json-server) is plain text, basically just one long string, which is then parsed since the server specified the data format as json.
* Think back to the sequence of events we just discussed. Which parts of the code are run? In what order? How often? Understanding the order of events is critical!
  * By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.
* There are many possible use cases for an effect hook other than fetching data from the server. However, this use is sufficient for us, for now.
---
---
### `Part 2: (d)` - Altering data in server
* The json-server does not exactly match the description provided by the textbook definition of a REST API, but neither do most other APIs claiming to be RESTful.
* In REST terminology, we refer to individual data objects, such as the notes in our application, as resources.
  * According to a general convention used by json-server, we would be able to locate an individual note at the resource URL notes/3, where 3 is the id of the resource.
* Resources are fetched from the server with HTTP GET requests.
* Creating a new resource for storing a note is done by making an HTTP POST request to the notes URL according to the REST convention that the json-server adheres to.
* We create a new object for the note but omit the id property, since it's better to let the server generate ids for our resources!
* We can use the inspector to check that the headers sent in the POST request are what we expected them to be, and that their values are correct.
  * In the Network tab of F12 (debugging).
  * Also note that we set the new state to add `response.data` not `noteObject`.
    * If something wrong happens => Check response.
* Once the data returned by the server starts to have an effect on the behavior of our web applications, we are immediately faced with a whole new set of challenges.
* Notice how every note receives its own unique event handler function, since the id of every note is unique.
* Individual notes stored in the json-server backend can be modified in two different ways by making HTTP requests to the note's unique URL. We can either replace the entire note with an HTTP PUT request, or only change some of the note's properties with an HTTP PATCH request.
* I am probably going to have a hard time noticing how they did the `toggleImportanceOf()` and applying the same principle in my code.
* On shallow-copy vs Deep-copy and `object spread syntax`:
  * [See](https://fullstackopen.com/en/part2/altering_data_in_server#changing-the-importance-of-notes)
```JS
const obj = {
    x: 1,
    y: {z: 2},
    k: {s: 5}
}

// This is shallow-copy for everything.
// const obj1 = obj

// This is shallow-copy for inside-objects, NOT values.
const obj1 = {...obj, y:{z: 3}}

// This doesn't reflect on obj, because it's deep-copy.
obj1.x = 2
// This doesn't reflect on obj, because it's specified above.
obj1.y.z = 4
// This *reflects* on obj, because it's shallow-copy.
obj.k.s = 10

console.log("obj: ", obj)
console.log("obj1: ",obj1)
// obj:  { x: 1, y: { z: 2 }, k: { s: 10 } }
// obj1: { x: 2, y: { z: 4 }, k: { s: 10 } }
```
* The map method creates a new array by mapping every item from the old array into an item in the new array. 
* Notice the naming convention and organization of `services/note.js` and how it's imported and exported.
* I don't think `response.data` would be always as done here by `json-server`.
* The modified `getAll` function still returns a promise, as the `then` method of a promise also returns a promise.
---
---
### END.
* React depends on re-rendering, and it kinda has a lot of it.
* Revise on **all** excercies solutions
* Effect hooks Vs. State hooks?
* Why use effect hooks?
* *Time Elapsed:* `~17H10M`
* *Stopped at:* `P2D - Cleaner syntax for...`